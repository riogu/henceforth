
running 1 test
test hfs::parser::tests::test_function_with_no_arguments ... FAILED

failures:

---- hfs::parser::tests::test_function_with_no_arguments stdout ----

thread 'hfs::parser::tests::test_function_with_no_arguments' (15338) panicked at src/hfs/parser.rs:392:9:
assertion failed: `(left == right)`

[1mDiff[0m [31m< left[0m / [32mright >[0m :
 UnresolvedAstArena {
     unresolved_exprs: [
         Literal(
             Integer(
                 4,
             ),
         ),
     ],
     unresolved_stmts: [
         StackBlock(
             [
                 UnresolvedExprId(
                     0,
                 ),
             ],
         ),
         Empty,
         BlockScope(
             [
                 Statement(
                     UnresolvedStmtId(
                         0,
                     ),
                 ),
[31m<                Statement([0m
[31m<                    UnresolvedStmtId([0m
[31m<                        1,[0m
[31m<                    ),[0m
[31m<                ),[0m
             ],
             Function,
         ),
         BlockScope(
             [],
             Function,
         ),
     ],
     unresolved_vars: [],
     unresolved_functions: [
         UnresolvedFunctionDeclaration {
             name: "no_args",
             param_type: TypeId(
                 4,
             ),
             return_type: TypeId(
                 5,
             ),
             body: UnresolvedStmtId(
                 2,
             ),
         },
         UnresolvedFunctionDeclaration {
             name: "main",
             param_type: TypeId(
                 4,
             ),
             return_type: TypeId(
                 4,
             ),
             body: UnresolvedStmtId(
                 3,
             ),
         },
     ],
     types: [
         Int,
         Float,
         Bool,
         String,
         Tuple(
             [],
         ),
         Tuple(
             [
                 TypeId(
                     0,
                 ),
             ],
         ),
     ],
     unresolved_expr_tokens: [
         Token {
[31m<            kind: Literal([0m
[31m<                Integer([0m
[31m<                    4,[0m
[31m<                ),[0m
[31m<            ),[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
[31m<                line_number: 1,[0m
[31m<                line_offset: 13,[0m
[31m<                token_width: 1,[0m
[32m>                line_number: 0,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
     ],
     unresolved_stmt_tokens: [
         Token {
[31m<            kind: [0m[1;48;5;52;31mA[0m[31mt,[0m
[32m>            kind: [0m[1;48;5;22;32mLe[0m[32mt,[0m
             source_info: SourceInfo {
[31m<                line_number: 1,[0m
[31m<                line_offset: 11,[0m
[31m<                token_width: 1,[0m
[32m>                line_number: 0,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
         Token {
[31m<            kind: [0m[1;48;5;52;31mS[0m[31me[0m[1;48;5;52;31mmicolon[0m[31m,[0m
[32m>            kind: [0m[1;48;5;22;32mL[0m[32me[0m[1;48;5;22;32mt[0m[32m,[0m
             source_info: SourceInfo {
[31m<                line_number: 1,[0m
[31m<                line_offset: 15,[0m
[31m<                token_width: 1,[0m
[32m>                line_number: 0,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
         Token {
[31m<            kind: Le[0m[1;48;5;52;31mf[0m[31mt[0m[1;48;5;52;31mBrace[0m[31m,[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
                 line_number: 0,
[31m<                line_offset: 10,[0m
[31m<                token_width: 1,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
         Token {
[31m<            kind: Le[0m[1;48;5;52;31mf[0m[31mt[0m[1;48;5;52;31mBrace[0m[31m,[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
[31m<                line_number: 4,[0m
[31m<                line_offset: 25,[0m
[31m<                token_width: 1,[0m
[32m>                line_number: 0,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
     ],
     unresolved_var_tokens: [],
     unresolved_function_tokens: [
         Token {
[31m<            kind: Identifier([0m
[31m<                "no_args",[0m
[31m<            ),[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
                 line_number: 0,
[31m<                line_offset: 2,[0m
[31m<                token_width: 1,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
         Token {
[31m<            kind: Identifier([0m
[31m<                "main",[0m
[31m<            ),[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
[31m<                line_number: 4,[0m
[31m<                line_offset: 18,[0m
[31m<                token_width: 1,[0m
[32m>                line_number: 0,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
     ],
     type_tokens: [
         Token {
             kind: Int,
             source_info: SourceInfo {
                 line_number: 0,
                 line_offset: 0,
                 token_width: 0,
             },
         },
         Token {
             kind: Float,
             source_info: SourceInfo {
                 line_number: 0,
                 line_offset: 0,
                 token_width: 0,
             },
         },
         Token {
             kind: Bool,
             source_info: SourceInfo {
                 line_number: 0,
                 line_offset: 0,
                 token_width: 0,
             },
         },
         Token {
             kind: String,
             source_info: SourceInfo {
                 line_number: 0,
                 line_offset: 0,
                 token_width: 0,
             },
         },
         Token {
[31m<            kind: Le[0m[1;48;5;52;31mf[0m[31mt[0m[1;48;5;52;31mParen[0m[31m,[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
                 line_number: 0,
[31m<                line_offset: 4,[0m
[31m<                token_width: 1,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
         Token {
[31m<            kind: Le[0m[1;48;5;52;31mf[0m[31mt[0m[1;48;5;52;31mParen[0m[31m,[0m
[32m>            kind: Let,[0m
             source_info: SourceInfo {
                 line_number: 0,
[31m<                line_offset: 7,[0m
[31m<                token_width: 1,[0m
[32m>                line_offset: 0,[0m
[32m>                token_width: 0,[0m
             },
         },
     ],
 }


note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    hfs::parser::tests::test_function_with_no_arguments

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 21 filtered out; finished in 0.00s

